%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% --------------------------------------------------------
% Rho
% LaTeX Template
% Version 2.1.1 (01/09/2024)
%
% Authors: 
% Guillermo Jimenez (memo.notess1@gmail.com)
% Eduardo Gracidas (eduardo.gracidas29@gmail.com)
% 
% License:
% Creative Commons CC BY 4.0
% --------------------------------------------------------
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[9pt,letterpaper,onecolumn]{rho-class/rho}
%\usepackage[english]{babel}

%% Spanish babel recomendation
\usepackage[spanish,es-nodecimaldot,es-noindentfirst]{babel}

\setbool{rho-abstract}{true} % Set false to hide the abstract
\setbool{corres-info}{true} % Set false to hide the corresponding author section

%----------------------------------------------------------
% TITLE
%----------------------------------------------------------

%\journalname{Example Template}
\title{DevGraph: Simulación de red social}

%----------------------------------------------------------
% AUTHORS AND AFFILIATIONS
%----------------------------------------------------------

\author[$\dagger$]{Franco Aguilar}
\author[$\dagger$]{Iván Mansilla}
\author[$\dagger$]{Diego Sanhueza}
\author[$\dagger$]{Duvan Figueroa}
\author[$\dagger$]{Miguel Maripillan}

%----------------------------------------------------------

%\affil[1]{Affiliation of author one}
%\affil[2]{Affiliation of author two}
%\affil[3]{Affiliation of author three}
\affil[$\dagger$]{Universidad de Magallanes}

%----------------------------------------------------------
% DATES
%----------------------------------------------------------

\dates{Informe fue compilado el día \today}

%----------------------------------------------------------
% FOOTER INFORMATION
%----------------------------------------------------------

%\leadauthor{Author last name et al.}
%\footinfo{Creative Commons CC BY 4.0}
\smalltitle{Estructuras de datos}
%\institution{Universidad de Magallanes}
\theday{\today} %\today

%----------------------------------------------------------
% ARTICLE INFORMATION
%----------------------------------------------------------

%\corres{Provide the corresponding author information and publisher here.}
%\email{example@organization.com.}
%\doi{\url{https://www.doi.org/exampledoi/XXXXXXXXXX}}

%\received{March 20, 2024}
%\revised{April 16, 2024}
%\accepted{April 20, 2024}
%\published{May 21, 2024}

%\license{Rho LaTeX Class \ccLogo\ This document is licensed under Creative Commons CC BY 4.0.}

%----------------------------------------------------------
% ABSTRACT
%----------------------------------------------------------

\begin{abstract}
    POR HACER
\end{abstract}

%----------------------------------------------------------

\keywords{C, Grafos, Red Social, Simulación, Estructuras de Datos}

%----------------------------------------------------------

\begin{document}
	
    \maketitle
    \thispagestyle{firststyle}
    \tableofcontents
    %\linenumbers

%----------------------------------------------------------

\section{Introducción}


\section{Objetivo Principal}

El objetivo principal de este proyecto fue consolidar y aplicar los conocimientos adquiridos sobre estructuras de datos mediante el desarrollo de un sistema práctico que simula el funcionamiento de una red social. A lo largo del proyecto, buscamos implementar y combinar diversas estructuras de datos, como grafos, tablas hash, listas enlazadas y colas de prioridad, en un contexto que nos permitiera comprender cómo se utilizan en sistemas como las redes sociales.

A través de este proyecto, nos enfocamos en diseñar e integrar algoritmos para optimizar la funcionalidad del sistema, con el fin de que el sistema fuera eficiente. Las funcionalidades clave que implementamos incluyen:

\begin{itemize}
    \item Crear un perfil de usuario.
    \item Establecer conexiones entre usuarios, representando las amistades en la red.
    \item Publicar y visualizar publicaciones propias y de amigos.
    \item Explorar y recomendar usuarios basándonos en afinidades o popularidad.
    \item Realizar búsquedas eficientes de usuarios.
\end{itemize}

Para lograr estos objetivos, hicimos uso de diversas estructuras de datos y algoritmos. Entre ellos:

\begin{itemize}
    \item \textbf{Grafos}: Utilizamos grafos para representar las conexiones entre los usuarios, donde cada usuario se considera un vértice y cada amistad se representa como una arista en un grafo no dirigido.
    \item \textbf{Tries o Árboles}: Implementamos tries para realizar búsquedas rápidas de nombres de usuario.
    \item \textbf{Tablas Hash}: Usamos tablas hash para almacenar perfiles y publicaciones, lo que permitió un acceso rápido a la información.
    \item \textbf{Colas de prioridad (Heaps)}: Utilizamos colas de prioridad para generar recomendaciones de usuarios y publicaciones basadas en afinidades o popularidad.
    \item \textbf{Listas enlazadas}: Gestionamos las publicaciones como listas enlazadas de nodos para manejar de manera eficiente las publicaciones de los usuarios.
\end{itemize}

Además, implementamos varios algoritmos fundamentales, tales como:

\begin{itemize}
    \item Búsqueda en grafos (BFS/DFS): Para sugerir nuevos amigos entre los amigos de los amigos.
    \item Caminos cortos (Dijkstra/BFS): Para encontrar usuarios cercanos en la red.
    \item Similaridad: Calculamos afinidades entre usuarios utilizando métodos como la Similaridad de Jaccard.
    \item Ordenación: Organizamos las publicaciones y recomendaciones de usuarios de manera eficiente.
\end{itemize}

A lo largo de este proyecto, consolidamos nuestros conocimientos en estructuras de datos, también aprendimos a integrarlos. Esto nos permitió desarrollar una red social, en la que los usuarios pueden interactuar, crear conexiones, publicar y recibir recomendaciones, todo optimizado mediante las estructuras y algoritmos sugeridos.


\section{Plantemiento del desarrollo del proyecto}

    \subsection{Grafos}
    Un grafo es una estructura de datos utilizada para modelar relaciones entre entidades.
    En este caso, se utilizarán grafos para representar nuestra red social, donde cada nodo será un usuario.
    Se detallarán las características principales que contiene el grafo desarrollado, explicando las decisiones tomadas. 
    Para implementar el grafo, se utilizó la representación de listas de adyacencia, dado que esta es eficiente en términos de memoria y se adapta bien a grafos dispersos.

    \subsubsection{Estructuras de Datos}
    \begin{itemize}
        \item Nodo: Representa cada conexión entre vértices.
        \item Lista: Almacena todos los nodos conectados a un vértice específico.
        \item Grafo: Contiene el número total de vértices y un arreglo de listas.
    \end{itemize}

    \subsubsection{Creación del Grafo}
    La función \texttt{crearGrafo} inicializa un grafo con un número especificado de vértices.

    \begin{verbatim}
    Grafo* crearGrafo(int numVertices) {
        Grafo* grafo = malloc(sizeof(Grafo));
        grafo->numVertices = numVertices;
        grafo->listas = malloc(numVertices * sizeof(Lista));

        for (int i = 0; i < numVertices; i++) {
            grafo->listas[i].cabeza = NULL;
        }

        return grafo;
    }
    \end{verbatim}

    \subsubsection{Adición de Aristas}
    La función \texttt{agregarArista} añade una conexión (arista) entre dos usuarios.

    \begin{verbatim}
    void agregarArista(Grafo* grafo, int origen, int destino) {
        Nodo* nuevoNodo = malloc(sizeof(Nodo));
        nuevoNodo->vertice = destino;
        nuevoNodo->siguiente = grafo->listas[origen].cabeza;
        grafo->listas[origen].cabeza = nuevoNodo;

        // Para grafos no dirigidos
        nuevoNodo = malloc(sizeof(Nodo));
        nuevoNodo->vertice = origen;
        nuevoNodo->siguiente = grafo->listas[destino].cabeza;
        grafo->listas[destino].cabeza = nuevoNodo;
    }
    \end{verbatim}

    \subsection{Generación de usuarios aleatorios}
    La generación de usuarios aleatorios es un proceso común en simulaciones y pruebas de software. 
    En este caso, se diseñó un algoritmo para generar nombres de usuarios aleatorios utilizando listas predefinidas de nombres y apellidos, combinándolos de forma aleatoria, lo que permite crear usuarios en nuestra red social.
    Estos usuarios posteriormente serán usados para conectarlos, crear sus intereses, analizar su perfil y generar un perfil psicológico.

    \subsubsection{Proceso de Generación}
    \begin{itemize}
        \item \textbf{Definición de Listas:} Se crearon dos listas predefinidas: una para los nombres y otra para los apellidos, que contienen un conjunto variado de cadenas de texto representando nombres comunes.
        \item \textbf{Selección Aleatoria:} Para cada usuario, se selecciona aleatoriamente un nombre y un apellido de sus respectivas listas usando la función \texttt{rand()}.
        \item \textbf{Concatenación:} Una vez seleccionados el nombre y apellido, se concatenan para formar un nombre completo.
        \item \textbf{Asignación:} El nombre generado se asigna al campo correspondiente del usuario.
    \end{itemize}

    \subsubsection{Ejemplo de Código}
    \begin{verbatim}
    const char *nombres[] = {"Carlos", "María", "Pedro", "Ana"};
    const char *apellidos[] = {"Pérez", "Gómez", "Rodríguez", "López"};

    for (int i = 0; i < quantity; i++) {
        int nameIndex = rand() % numNames;
        int usernameIndex = rand() % numUsernames;
        int passwordIndex = rand() % numPasswords;

        char *name = strdup(names[nameIndex]);
        char *username = strdup(usernames[usernameIndex]);
        char *password = strdup(passwords[passwordIndex]);

        if (search_in_hash_table(table, username)) {
            printf("Advertencia: El nombre de usuario '%s' ya existe. Saltando...\n", username);
            free(name);
            free(username);
            free(password);
            continue;
        }

        User newUser = create_new_user(username, password, name, table, graph, globalInterests);
        if (!newUser) {
            printf("Error al crear el usuario '%s'.\n", username);
            free(name);
            free(username);
            free(password);
            continue;
        }

        for(int i=0; i<rand()%globalInterests.numInterests; i++) {
            add_interest(newUser, globalInterests, rand()% globalInterests.numInterests);
        }

        printf("Usuario creado: %s (%s)\n", name, username);

        free(name);
        free(username);
        free(password);
    }
    \end{verbatim}

    \subsubsection{Ventajas y Limitaciones}
    \textbf{Ventajas:}
    \begin{itemize}
        \item Permite simular usuarios según la cantidad indicada por el usuario.
        \item Garantiza la variabilidad en los datos generados.
    \end{itemize}
    \textbf{Limitaciones:}
    \begin{itemize}
        \item La calidad de los nombres generados depende del tamaño y diversidad de las listas predefinidas.
        \item En escenarios de gran escala, es posible que se repitan nombres si las listas son pequeñas.
    \end{itemize}

    \subsection{Conexión entre Usuarios}
    La conexión entre usuarios en el sistema se implementa mediante un grafo, donde cada nodo representa un usuario y las aristas indican la relación entre ellos.
    Esta estructura permite modelar redes sociales o sistemas similares.

    \subsubsection{Proceso de Creación de Conexiones}
    \begin{itemize}
        \item \textbf{Inicialización del Grafo:} El grafo se inicializa en memoria, permitiendo agregar nodos y conexiones dinámicamente.
        \item \textbf{Selección Aleatoria de Conexiones:} Se selecciona aleatoriamente un número de conexiones para cada usuario, limitado por un valor máximo.
        \item \textbf{Verificación de Conexiones:} Se verifica que las conexiones no sean duplicadas ni auto-conexiones.
        \item \textbf{Establecimiento de Conexiones:} Si la conexión es válida, se actualiza la lista de conexiones de ambos usuarios.
    \end{itemize}

    \subsubsection{Ventajas y Limitaciones}
    \textbf{Ventajas:}
    \begin{itemize}
        \item Proporciona una forma sencilla y efectiva de simular una red de usuarios.
        \item La implementación dinámica permite adaptarse a cambios en el tamaño del sistema.
    \end{itemize}
    \textbf{Limitaciones:}
    \begin{itemize}
        \item La selección aleatoria podría generar distribuciones desiguales de conexiones.
        \item En sistemas de gran escala, el proceso puede ser computacionalmente costoso.
    \end{itemize}

    \subsection{Implementación de Dijkstra}
    El algoritmo de Dijkstra es una técnica eficiente para encontrar la ruta más corta en un grafo ponderado.
    En este caso, se utiliza para encontrar usuarios cercanos en la red social, asignando un peso entre las conexiones. 

    \subsubsection{Descripción del Algoritmo}
    Este algoritmo se utiliza para calcular las distancias mínimas desde un nodo fuente hacia todos los demás nodos. 
    Una vez que se calculan las distancias, es posible filtrar a los usuarios más cercanos mediante un parámetro.

    \subsubsection{Estructura de Datos}
    \begin{verbatim}
    struct _edge {
        User dest; /*!< Usuario destino */
        double weight; /*!< Peso de la arista */
        Edge next; /*!< Siguiente en la lista de aristas */
    };
    \end{verbatim}


\section{Implementación}

    \rhostart{P}OR HACER

\section{Gestión del equipo de trabajo}

    A continuación, se presenta una descripción detallada de las tareas asignadas y realizadas por cada miembro del equipo.
    
    \subsection{Miembros del equipo y sus contribuciones}
    
    \begin{itemize}
        \item \textbf{Duvan Figueroa:} \\
        Duvan se encargó de la implementación de las \textbf{tablas hash} que permiten el almacenamiento eficiente de datos en la red social. Además, trabajó en la \textbf{organización de publicaciones}, gestionando cómo se almacenan y visualizan las publicaciones en la plataforma.
    
        \item \textbf{Diego Sanhueza:} \\
        Diego fue responsable de la implementación de la \textbf{estructura de grafos} en conjunto con Miguel, lo que facilita la representación de las conexiones entre usuarios. También desarrolló el \textbf{algoritmo de Dijkstra} para encontrar usuarios cercanos basados en la ubicación o afinidades. Además, trabajó en la creación de perfiles psicológicos de los usuarios y en la implementación de \textbf{usuarios aleatorios} para probar el sistema.
    
        \item \textbf{Iván Mansilla:} \\
        Iván implementó las \textbf{listas enlazadas} para manejar las publicaciones, así como la creación de \textbf{estructuras de usuarios}, las cuales incluyen la lista enlazada de publicaciones. También se encargó de agregar \textbf{temas/tópicos} en la estructura de usuarios y publicaciones, y de implementar el índice \textbf{Jaccard} para medir las similitudes entre usuarios y publicaciones. Además, fue responsable de la asignación de intereses a los usuarios y de la implementación de funcionalidades para \textbf{iniciar sesión} y \textbf{publicar} según el usuario iniciado. Por último, implementó los comandos para publicar, borrar, ver usuarios, perfil, publicaciones, entre otros.
    
        \item \textbf{Franco Aguilar:} \\
        Franco fue responsable de la implementación de \textbf{colas de prioridad}, que permiten gestionar las tareas de manera eficiente y priorizar las acciones dentro de la red social.
    
        \item \textbf{Miguel Maripillan:} \\
        Miguel trabajó en conjunto con Diego en la implementación de la \textbf{estructura de grafos} y los \textbf{algoritmos BFS/DFS} para explorar las conexiones entre usuarios de manera eficiente. Además, se encargó del \textbf{almacenamiento de la información de los usuarios} en la nube y de la \textbf{carga de usuarios} a través de un archivo \texttt{txt} de entrada.
    \end{itemize}

\section{Posibles mejoras}

    \rhostart{P}OR HACER

\section{Ejemplo de uso}

    \rhostart{P}OR HACER

\section{Conclusiones}

    En este proyecto, logramos implementar con éxito una red social simulada que cumple con todas las funcionalidades necesarias. Pudimos crear y conectar usuarios, gestionar publicaciones y compartirlas de acuerdo con los intereses y amistades dentro de la red. Además, implementamos funcionalidades avanzadas, como la recomendación de nuevos usuarios y publicaciones, lo cual añadio un extra a la experiencia de la red social simulada.

    Uno de los aspectos destacables de este proyecto fue la integración del perfil psicológico como una funcionalidad extra. También aprendimos y utilizamos diversas estructuras de datos y algoritmos que resultaron fundamentales para el buen funcionamiento del programa.

    En cuanto a las estructuras de datos, utilizamos grafos para representar las conexiones entre usuarios, lo que nos permitió simular las relaciones de amistad. Los algoritmos de BFS y DFS fueron implementados para explorar las conexiones entre usuarios y gestionar las rutas en la red social de manera eficiente.

    Este proyecto fue una excelente oportunidad para poner en práctica nuestros conocimientos sobre estructuras de datos y algoritmos, nos permitió profundizar en temas como tablas hash, colas de prioridad, listas enlazadas y la similitud de Jaccard. Todo el proceso nos permitió aprender de manera práctica y aplicar conceptos de la teoría de estructuras, lo que fortaleció nuestras habilidades en programación.

    En resumen, el desarrollo de esta red social fue exitoso, cumplimos con todos los objetivos planteados y adquirimos nuevos conocimientos valiosos.

\section{Rho packages}

        \begin{rhoenv}[frametitle=Environment with custom title]
            Hello! I am an example of the \textit{rhoenv} included in rhoenvs \LaTeX\ package. Here you can include relevant information or notes about your work. You can modify my title directly in the code.
        \end{rhoenv}

\section{Codes}

    This class\footnote{Hello there! I am a footnote :)} includes the \textit{listings} package, which offers customized features for adding codes specially for C, C++, \LaTeX\ and Matlab. You can customize the format in \textit{rho class} file.

    \lstinputlisting[caption=Example of matlab code., label={lst:listing-Mat}, language=Matlab]{example.m}

    
        
%----------------------------------------------------------

\section{Referencias}


%----------------------------------------------------------

\end{document}